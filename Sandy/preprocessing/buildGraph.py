
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
import seaborn as sb

class ProcNetwork:

    def __init__(self, df_obj):
        self.object = df_obj

    def produce_edge_list(self, source, target, target_node=False):

        self.network = nx.from_pandas_edgelist(self.object,
                                               source=source,
                                               target=target,
                                               edge_attr=True)

    def assign_labels(self, label_name='ProcName'):
        labels = dict(zip(self.network.nodes(), self.object[label_name]))
        self.network = nx.relabel_nodes(self.network, labels, copy=False)

    def assign_attribute(self, attr_name='targetIDX'):

        attr = dict(zip(self.network.nodes(), self.object[attr_name]))
        nx.set_node_attributes(self.network, attr, 'NodeAttr')

        self.attr_colors = create_color_map(self.network, 'NodeAttr')

    def create_target(self, target_name, new_node=False):

        master_df = pd.DataFrame([])

        ## Extract the PID of the parent process
        target = self.object.loc[self.object['ProcName'] == target_name, ['PID']]
        ## Append the parent process, as well as that of their children
        df = self.object.assign(targetIDX=(self.object.PPID.isin(target.PID).astype(int)) | (self.object.PID.isin(target.PID).astype(int)))

        ## New targets becomes current parent and new children; thereby propogating the tree
        target = df[df['targetIDX'] == 1]
        master_df = master_df.append(target)

        target_len = len(master_df)

        while True:

            ## Assign an integer to items matching the PID of parent
            df = df.assign(targetIDX=df.PPID.isin(target.PID).astype(int))
            ## Extract the items into a seperate df
            target = df[df['targetIDX'] == 1]
            ## Append the target items to the master df
            master_df = master_df.append(target)

            ## If master_df stays the same size, the malicious tree must be covered
            if len(master_df) == target_len:
                df = df.assign(targetIDX=df.PID.isin(master_df.PID).astype(int))
                self.object = df
                self.produce_edge_list('PID','PPID')
                self.assign_labels()
                break
            else:
                ## Set new len to old len
                target_len = len(master_df)

        if new_node:
            return ProcNetwork(master_df)

    def plot_network(self, save=False, map_feature=False):

        fig = plt.figure()
        layout = nx.spring_layout(self.network)
        #n_colors = 'blue' #Default nodes to blue

        self.assign_attribute('targetIDX')
        #durations = [int(i['TimeStamp']) for i in dict(self.network.edges).values()]
        #duration = list(filter(lambda x: x != 0, durations))

        #min_, max_ = min(duration), max(duration)
        #durations = [(0.1 - 1)*((i - max_)/(min_ - max_)) + 1  for i in durations]

        nx.draw_networkx_nodes(self.network,pos=layout,node_size=10,
                               node_color='green')
        nx.draw_networkx_edges(self.network,pos=layout,width=0.5,style='dashed',
                               edge_color='red',edge_cmap=plt.cm.Blues)
        nx.draw_networkx_labels(self.network, pos=layout,font_size=3)

        plt.show()

        if save:
            fig.savefig('figure.png', format='png', dpi=300, bbox_inches='tight')

    def _columns(self):
        return self.object.columns

    def _info(self):
        return self.object.shape

    def _return_df(self):
        return self.object

    def _unique(self, group_by):
        return self.object[group_by].unique()


def create_color_map(G, attrib, sb_palette="RdBu_r"):
    """
    Code retrieved from Networkx Youtube video at PyData2016
    """

    attributes = [G.node[label][attrib] for label in G.nodes()]

    attributes_unique = list(set(attributes))
    num_values = len(attributes_unique)

    palette = sb.color_palette(sb_palette, num_values).as_hex()
    color_map = dict(zip(attributes_unique, palette))
    node_colors = [color_map[attribute] for attribute in attributes]

    return node_colors


## Set Parameters
#source =
#target =
